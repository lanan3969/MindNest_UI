<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>Three.js 四季树 - 优化积雪版</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: #fff;
        }

        /* --- 模糊背景层 --- */
        body::before {
            content: "";
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            /* 背景图片 */
            background-image: url('./背景.png'); 
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            /* 模糊程度 */
            filter: blur(4px);
            transform: scale(1.05); 
        }

        body, .dg.main {
            text-shadow: 0 1px 3px rgba(0,0,0,0.8);
        }

        canvas {
            display: block;
            background: transparent; 
        }

        .dg.main .close-button {
            background-color: #222;
        }
        .dg.main {
            color: #eee;
        }
        
        /* --- 任务条样式 --- */
        #task-overlay {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0.9);
            background: rgba(16, 24, 32, 0.85);
            backdrop-filter: blur(8px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            padding: 30px 50px;
            border-radius: 16px;
            text-align: center;
            color: #ffeeb3;
            font-size: 1.5rem;
            font-weight: 300;
            letter-spacing: 1px;
            box-shadow: 0 0 30px rgba(255, 238, 179, 0.15), inset 0 0 20px rgba(255, 255, 255, 0.05);
            opacity: 0;
            visibility: hidden;
            transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            z-index: 1000;
            cursor: pointer;
            user-select: none;
            max-width: 80%;
            text-shadow: none;
        }

        #task-overlay.active {
            opacity: 1;
            visibility: visible;
            transform: translate(-50%, -50%) scale(1);
        }

        #task-overlay:hover {
            background: rgba(25, 35, 45, 0.95);
            box-shadow: 0 0 40px rgba(255, 238, 179, 0.3);
        }

        .instruction {
            position: absolute;
            bottom: 20px;
            width: 100%;
            text-align: center;
            color: rgba(255,255,255,0.8);
            pointer-events: none;
            font-size: 0.9rem;
        }
    </style>
</head>
<body>

<!-- 任务显示层 -->
<div id="task-overlay">Task goes here</div>
<div class="instruction">点击漂浮的光球获取今日任务 | 在右上角菜单选择 "Cycle" 开启四季轮换</div>

<script type="importmap">
{
    "imports": {
        "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
    }
}
</script>

<script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { GUI } from 'https://unpkg.com/dat.gui@0.7.9/build/dat.gui.module.js';

    // --- 任务列表数据 ---
    const taskList = [
        "Start a creative journal.",
        "Listen to a new podcast or album.",
        "Try a new recipe.",
        "Engage in a creative outlet.",
        "Practice mindfulness or meditation.",
        "Reach out to a friend.",
        "Volunteer for a cause you care about.",
        "Join a club or group.",
        "Go to a local museum or park.",
        "Have a 'co-watching' session with a friend.",
        "Take a short walk or jog.",
        "Spend time in nature.",
        "Try a new sport or physical activity.",
        "Go for a bike ride or skate.",
        "Do some gentle stretching or yoga.",
        "Tidy up your space.",
        "Make your bed every morning.",
        "Create a 'done' list.",
        "Plan something to look forward to.",
        "Take a long bath or shower."
    ];

    // --- 核心变量 ---
    let scene, camera, renderer, controls;
    let directionalLight;
    let treeGroup, leafPoints, snowOnBranch;
    const particleOrbs = [];
    const particleExplosions = [];
    let raycaster, mouse;
    
    // UI 元素
    const taskOverlay = document.getElementById('task-overlay');

    // --- 配置对象 ---
    const params = {
        season: 'Summer',
        resetOrbs: () => resetOrbs(),
    };

    const seasons = {
        Spring: { color1: new THREE.Color("#98FB98"), color2: new THREE.Color("#FFB6C1"), leafSize: 35 },
        Summer: { color1: new THREE.Color("#2E8B57"), color2: new THREE.Color("#3CB371"), leafSize: 45 },
        Autumn: { color1: new THREE.Color("#FFA500"), color2: new THREE.Color("#DC143C"), leafSize: 40 },
        Winter: { color1: new THREE.Color("#FFFFFF"), color2: new THREE.Color("#E0E0E0"), leafSize: 15 },
    };

    // --- 季节循环逻辑变量 ---
    let isCycling = false;
    let cycleTime = 0;
    const cycleDuration = 20; 
    const seasonOrder = ['Spring', 'Summer', 'Autumn', 'Winter'];

    // --- 初始化函数 ---
    function init() {
        // 1. 场景
        scene = new THREE.Scene();

        // 2. 渲染器
        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.setClearColor(0x000000, 0); 
        
        document.body.appendChild(renderer.domElement);

        // 3. 相机
        camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(15, 10, 35);
        camera.lookAt(0, 10, 0);

        // 4. 光照
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        directionalLight = new THREE.DirectionalLight(0xffffff, 1.5);
        directionalLight.position.set(20, 40, 20);
        directionalLight.castShadow = true;
        directionalLight.shadow.camera.top = 25;
        directionalLight.shadow.camera.bottom = -25;
        directionalLight.shadow.camera.left = -25;
        directionalLight.shadow.camera.right = 25;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        scene.add(directionalLight);

        // 5. 控制器
        controls = new OrbitControls(camera, renderer.domElement);
        controls.target.set(0, 10, 0);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;

        // 6. 地面
        const groundGeo = new THREE.PlaneGeometry(100, 100);
        const groundMat = new THREE.MeshStandardMaterial({ 
            color: 0x111111, 
            roughness: 0.8,
            transparent: true,
            opacity: 0.6 
        });
        const ground = new THREE.Mesh(groundGeo, groundMat);
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        scene.add(ground);

        // 7. 创建核心元素
        createTree();
        createOrbs(8);

        // 8. 交互系统
        raycaster = new THREE.Raycaster();
        mouse = new THREE.Vector2();
        window.addEventListener('click', onMouseClick);
        window.addEventListener('resize', onWindowResize);
        
        taskOverlay.addEventListener('click', hideTask);

        // 9. UI
        createGUI();

        // 10. 启动动画
        animate();
    }

    // --- 树木创建 ---
    function createTree() {
        treeGroup = new THREE.Group();
        scene.add(treeGroup);

        const barkMaterial = new THREE.MeshStandardMaterial({
            color: 0x604020,
            roughness: 0.9,
            metalness: 0.1,
        });

        const mainTrunk = createBranch(1, 15, new THREE.Vector3(0, 7.5, 0), barkMaterial);
        treeGroup.add(mainTrunk);

        const branches = [];
        for (let i = 0; i < 5; i++) {
            const height = 8 + Math.random() * 6;
            const angle = (i / 5) * Math.PI * 2 + Math.random() * 0.5;
            const radius = 0.5 + Math.random() * 0.5;
            const branch = createBranch(0.3 + Math.random() * 0.3, 5 + Math.random() * 3, 
                new THREE.Vector3(Math.cos(angle) * radius, height, Math.sin(angle) * radius), barkMaterial, 
                new THREE.Euler(Math.random() * 0.5, angle, Math.random() * 0.5 - 0.25)
            );
            treeGroup.add(branch);
            branches.push(branch);
        }
        
        createLeaves(mainTrunk, branches);
        snowOnBranch = createSnowLayer(mainTrunk, branches);
        snowOnBranch.visible = false;
        treeGroup.add(snowOnBranch);

        setSeason(params.season);
    }
    
    function createBranch(radius, height, position, material, rotation) {
        const geo = new THREE.CylinderGeometry(radius * 0.8, radius, height, 16);
        const branch = new THREE.Mesh(geo, material);
        branch.position.copy(position);
        if (rotation) {
            branch.rotation.copy(rotation);
        }
        branch.castShadow = true;
        branch.receiveShadow = true;
        return branch;
    }

    function createLeaves(trunk, branches) {
        const leafCount = 20000;
        const leafGeometry = new THREE.BufferGeometry();
        const positions = new Float32Array(leafCount * 3);
        const randomness = new Float32Array(leafCount);
        const colorTypes = new Float32Array(leafCount);

        const leafVolume = new THREE.Sphere(new THREE.Vector3(0, 15, 0), 10);

        for (let i = 0; i < leafCount; i++) {
            const vertex = new THREE.Vector3(
                (Math.random() - 0.5) * 25,
                Math.random() * 15,
                (Math.random() - 0.5) * 25
            );
            vertex.y += 8;

            if (leafVolume.containsPoint(vertex)) {
                positions[i * 3] = vertex.x;
                positions[i * 3 + 1] = vertex.y;
                positions[i * 3 + 2] = vertex.z;
                randomness[i] = Math.random();
                colorTypes[i] = Math.random() > 0.5 ? 0 : 1;
            }
        }

        leafGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        leafGeometry.setAttribute('randomness', new THREE.BufferAttribute(randomness, 1));
        leafGeometry.setAttribute('colorType', new THREE.BufferAttribute(colorTypes, 1));
        
        const leafMaterial = new THREE.PointsMaterial({
            size: 0.2,
            vertexColors: true,
            sizeAttenuation: true,
            transparent: true,
            alphaMap: createCircleTexture(0.5),
            depthWrite: false,
            blending: THREE.AdditiveBlending,
        });

        const colors = new Float32Array(leafCount * 3);
        leafGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

        leafPoints = new THREE.Points(leafGeometry, leafMaterial);
        leafPoints.castShadow = true;
        treeGroup.add(leafPoints);
    }
    
    function createSnowLayer(trunk, branches) {
        const snowGroup = new THREE.Group();
        const snowMaterial = new THREE.MeshStandardMaterial({
            color: 0xffffff,
            roughness: 0.7,
            metalness: 0.0,
            transparent: true,
            opacity: 1.0
        });

        [trunk, ...branches].forEach(branch => {
            const snowGeo = new THREE.CylinderGeometry(
                branch.geometry.parameters.radiusTop * 1.1, 
                branch.geometry.parameters.radiusBottom * 1.1, 
                branch.geometry.parameters.height, 
                branch.geometry.parameters.radialSegments
            );
            const snowMesh = new THREE.Mesh(snowGeo, snowMaterial);
            snowMesh.position.copy(branch.position).add(new THREE.Vector3(0, 0.1, 0)); 
            snowMesh.rotation.copy(branch.rotation);
            snowMesh.scale.y = 0.1; 
            snowMesh.position.y = branch.position.y + branch.geometry.parameters.height / 2 * 0.9;
            snowMesh.castShadow = true;
            snowGroup.add(snowMesh);
        });
        
        return snowGroup;
    }

    // --- 季节管理逻辑（核心修改） ---
    function updateSeasonCycle(delta) {
        if (!isCycling || !leafPoints) return;

        cycleTime += delta;
        const progress = (cycleTime % cycleDuration) / cycleDuration;
        const stage = progress * 4;
        const currentIdx = Math.floor(stage);
        const nextIdx = (currentIdx + 1) % 4;
        const lerpFactor = stage - currentIdx;

        // 更新叶子颜色
        const currentSeason = seasons[seasonOrder[currentIdx]];
        const nextSeason = seasons[seasonOrder[nextIdx]];

        const tempColor1 = currentSeason.color1.clone().lerp(nextSeason.color1, lerpFactor);
        const tempColor2 = currentSeason.color2.clone().lerp(nextSeason.color2, lerpFactor);
        
        const targetSize = THREE.MathUtils.lerp(currentSeason.leafSize, nextSeason.leafSize, lerpFactor);
        leafPoints.material.size = targetSize / 100;

        const colors = leafPoints.geometry.attributes.color.array;
        const colorTypes = leafPoints.geometry.attributes.colorType.array;
        
        for (let i = 0; i < colorTypes.length; i++) {
            const color = colorTypes[i] === 0 ? tempColor1 : tempColor2;
            colors[i * 3] = color.r;
            colors[i * 3 + 1] = color.g;
            colors[i * 3 + 2] = color.b;
        }
        leafPoints.geometry.attributes.color.needsUpdate = true;

        // --- 积雪显示逻辑优化 ---
        let snowOpacity = 0;

        if (currentIdx === 0) { 
            // 春季 (Index 0): 积雪快速消融 (Spring -> Summer)
            // 修改：乘以 3 倍速，意味着春季开始的前 1/3 时间雪就化完了，剩下时间无雪
            snowOpacity = Math.max(0, 1 - lerpFactor * 3); 
        } 
        else if (currentIdx === 1) { 
            // 夏季 (Index 1): 完全无雪
            snowOpacity = 0; 
        } 
        else if (currentIdx === 2) { 
            // 秋季 (Index 2): 大部分时间无雪，只在最后过渡到冬季时显现
            // 修改：直到最后 20% 的时间才开始出现雪
            if (lerpFactor > 0.8) {
                snowOpacity = (lerpFactor - 0.8) * 5; 
            } else {
                snowOpacity = 0;
            }
        } 
        else if (currentIdx === 3) { 
            // 冬季 (Index 3): 全雪 (Winter -> Spring)
            // 整个冬季保持不透明度为 1，直到切换到春季开始消融
            snowOpacity = 1; 
        }

        // 关键修复：当透明度极低时，直接隐藏物体，防止出现幽灵般的白层
        if (snowOpacity <= 0.01) {
            snowOnBranch.visible = false;
        } else {
            snowOnBranch.visible = true;
            snowOnBranch.children.forEach(mesh => {
                mesh.material.opacity = snowOpacity;
                mesh.material.transparent = true;
            });
        }
    }

    function setSeason(seasonName) {
        if (seasonName === 'Cycle') {
            isCycling = true;
            return;
        }
        isCycling = false;

        const season = seasons[seasonName];
        const colors = leafPoints.geometry.attributes.color.array;
        const colorTypes = leafPoints.geometry.attributes.colorType.array;
        const color1 = season.color1;
        const color2 = season.color2;

        leafPoints.material.size = season.leafSize / 100;

        // 静态季节设置：仅冬季显示雪
        if (seasonName === 'Winter') {
            snowOnBranch.visible = true;
            snowOnBranch.children.forEach(m => { 
                m.material.opacity = 1; 
                m.material.transparent = false; 
            });
        } else {
            snowOnBranch.visible = false;
        }

        for (let i = 0; i < colorTypes.length; i++) {
            const color = colorTypes[i] === 0 ? color1 : color2;
            if (seasonName === 'Spring' && Math.random() < 0.1) {
                 colors[i * 3] = color2.r;
                 colors[i * 3 + 1] = color2.g;
                 colors[i * 3 + 2] = color2.b;
            } else {
                 colors[i * 3] = color.r;
                 colors[i * 3 + 1] = color.g;
                 colors[i * 3 + 2] = color.b;
            }
        }
        leafPoints.geometry.attributes.color.needsUpdate = true;
    }

    // --- 粒子系统 ---
    function createOrbs(count) {
        for (let i = 0; i < count; i++) {
            const orb = new ParticleOrb();
            particleOrbs.push(orb);
            scene.add(orb.points);
        }
    }

    function resetOrbs() {
        particleOrbs.forEach(orb => scene.remove(orb.points));
        particleOrbs.length = 0;
        createOrbs(8);
    }
    
    class ParticleOrb {
        constructor() {
            const geo = new THREE.BufferGeometry();
            geo.setAttribute('position', new THREE.BufferAttribute(new Float32Array([0, 0, 0]), 3));
            const mat = new THREE.PointsMaterial({
                size: 4, 
                color: 0xffeeb3,
                transparent: true,
                blending: THREE.AdditiveBlending,
                map: createCircleTexture(1.0),
                depthWrite: false,
                sizeAttenuation: true
            });
            this.points = new THREE.Points(geo, mat);
            
            this.angle = Math.random() * Math.PI * 2;
            this.radius = 12 + Math.random() * 5;
            this.speed = 0.0001 + Math.random() * 0.0005;
            this.yOffset = 5 + Math.random() * 10;
            this.time = Math.random() * 1000;
        }

        update(delta) {
            this.angle += this.speed * delta * 50;
            this.time += delta * 0.5;

            this.points.position.x = Math.cos(this.angle) * this.radius;
            this.points.position.z = Math.sin(this.angle) * this.radius;
            this.points.position.y = this.yOffset + Math.sin(this.time) * 2;
            
            this.points.material.size = 3.5 + Math.sin(this.time * 2) * 1.0;
            this.points.material.opacity = 0.7 + Math.sin(this.time * 2) * 0.3;
        }
    }
    
    class ParticleExplosion {
        constructor(origin) {
            const particleCount = 200;
            const geo = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const velocities = [];

            for (let i = 0; i < particleCount; i++) {
                positions[i*3] = origin.x;
                positions[i*3+1] = origin.y;
                positions[i*3+2] = origin.z;
                const vel = new THREE.Vector3(
                    (Math.random() - 0.5), 
                    (Math.random() - 0.5), 
                    (Math.random() - 0.5)
                );
                vel.normalize().multiplyScalar(Math.random() * 3 + 2);
                velocities.push(vel);
            }
            geo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            this.velocities = velocities;

            const mat = new THREE.PointsMaterial({
                size: 0.15,
                color: 0xffeeb3,
                transparent: true,
                opacity: 1.0,
                blending: THREE.AdditiveBlending,
                map: createCircleTexture(1.0),
                depthWrite: false,
                sizeAttenuation: true
            });
            this.points = new THREE.Points(geo, mat);
            this.life = 2.0; 
            this.gravity = 0.05;
            scene.add(this.points);
        }

        update(delta) {
            this.life -= delta;
            if (this.life <= 0) {
                this.dispose();
                return;
            }
            this.points.material.opacity = this.life / 2.0;
            const positions = this.points.geometry.attributes.position.array;
            for (let i = 0; i < this.velocities.length; i++) {
                this.velocities[i].y -= this.gravity * delta * 5;
                positions[i*3] += this.velocities[i].x * delta;
                positions[i*3+1] += this.velocities[i].y * delta;
                positions[i*3+2] += this.velocities[i].z * delta;
            }
            this.points.geometry.attributes.position.needsUpdate = true;
        }

        dispose() {
            scene.remove(this.points);
            this.points.geometry.dispose();
            this.points.material.dispose();
        }
    }

    // --- 任务管理 ---
    function showRandomTask() {
        const randomTask = taskList[Math.floor(Math.random() * taskList.length)];
        taskOverlay.innerText = randomTask;
        taskOverlay.classList.add('active');
    }

    function hideTask(event) {
        event.stopPropagation();
        taskOverlay.classList.remove('active');
    }

    // --- 交互 ---
    function onMouseClick(event) {
        if (taskOverlay.classList.contains('active')) return;

        event.preventDefault();
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        raycaster.setFromCamera(mouse, camera);

        const orbMeshes = particleOrbs.map(orb => orb.points);
        raycaster.params.Points.threshold = 1; 
        const intersects = raycaster.intersectObjects(orbMeshes);
        
        if (intersects.length > 0) {
            const intersectedObject = intersects[0].object;
            const orbIndex = orbMeshes.indexOf(intersectedObject);
            if (orbIndex > -1) {
                const explosion = new ParticleExplosion(intersectedObject.position);
                particleExplosions.push(explosion);
                scene.remove(intersectedObject);
                particleOrbs.splice(orbIndex, 1);
                showRandomTask();
            }
        }
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }
    
    // --- UI ---
    function createGUI() {
        const gui = new GUI();
        gui.add(params, 'season', ['Spring', 'Summer', 'Autumn', 'Winter', 'Cycle']).name('Season').onChange(setSeason);
        gui.add(params, 'resetOrbs').name('Reset Orbs');
    }

    // --- 动画 ---
    const clock = new THREE.Clock();
    function animate() {
        requestAnimationFrame(animate);
        const delta = clock.getDelta();

        updateSeasonCycle(delta);
        controls.update();

        particleOrbs.forEach(orb => orb.update(delta));
        
        for (let i = particleExplosions.length - 1; i >= 0; i--) {
            const explosion = particleExplosions[i];
            explosion.update(delta);
            if (explosion.life <= 0) {
                particleExplosions.splice(i, 1);
            }
        }

        renderer.render(scene, camera);
    }
    
    function createCircleTexture(alpha) {
        const canvas = document.createElement('canvas');
        canvas.width = 64;
        canvas.height = 64;
        const context = canvas.getContext('2d');
        const gradient = context.createRadialGradient(
            canvas.width / 2, canvas.height / 2, 0, 
            canvas.width / 2, canvas.height / 2, canvas.width / 2
        );
        gradient.addColorStop(0, `rgba(255, 255, 255, ${alpha})`);
        gradient.addColorStop(0.5, `rgba(255, 255, 255, ${alpha * 0.7})`);
        gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
        context.fillStyle = gradient;
        context.fillRect(0, 0, canvas.width, canvas.height);
        const texture = new THREE.CanvasTexture(canvas);
        texture.needsUpdate = true;
        return texture;
    }

    init();

</script>
</body>
</html>